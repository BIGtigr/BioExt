#!/usr/bin/env python3

import os
import signal
import sys

from operator import itemgetter
from random import shuffle
from re import compile as re_compile

from Bio.Alphabet import single_letter_alphabet
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord

from BioExt.io import BamIO
from BioExt.joblib import Parallel, delayed
from BioExt.quiver import NoQVsModelParams, extractFeatures, refineConsensus

import ConsensusCore as cc


# global alignment seems to work best ... I don't know why
LOCAL_ALIGNMENT = False
QV_NITER = 20
realph = re_compile(r'[^ACGT]')


def left_pos(seq):
    return seq.annotations['position']


def right_pos(seq):
    for i in range(len(seq) - 1, -1, -1):
        # skip all trailing ambigs
        if seq[i].upper() in 'ACGT':
            return i + 1
    return i


def proper(string):
    return realph.sub('', string.upper())


def _consensus(reads):
    shuffle(reads)
    config = cc.PoaConfig()
    config.UseLocalAlignment = LOCAL_ALIGNMENT
    return cc.PoaConsensus.FindConsensus(
        reads,
        config
        ).Sequence()


def main(
    bam_handle,
    output_handle,
    coverage,
    nestimates,
    quiver,
    window_size
    ):

    try:
        signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    except ValueError:
        pass

    try:
        n_jobs = int(os.environ.get('NCPU', -1))
    except ValueError:
        n_jobs = -1

    if n_jobs == 0:
        n_jobs = None

    # sort by left position, then filter empty reads
    reads = [
        read
        for read, _ in sorted(
            (
                (proper(str(seq.seq)), left_pos(seq))
                for seq in BamIO.parse(bam_handle)
                ),
            key=itemgetter(1)
            )
        if len(read)
        ]

    if not reads:
        raise RuntimeError(
            'no valid reads present'
            )

    # divide by 2 because windows are drawn in forward and reverse
    stride = max(1, coverage // (nestimates // 2))
    windows = []

    for start in range(0, len(reads), stride):
        stop = min(len(reads), start + coverage)
        windows.append((start, stop))

    for stop in range(len(reads), 0, -stride):
        start = max(0, stop - coverage)
        windows.append((start, stop))

    parts = list(Parallel(
        n_jobs=n_jobs,
        verbose=0,
        pre_dispatch='10 * n_jobs'
        )(
            delayed(_consensus)(reads[start:stop])
            for start, stop in windows
            )
        )

    # is this a good thing?
    shuffle(parts)

    poa_config = cc.PoaConfig()
    poa_config.UseLocalAlignment = LOCAL_ALIGNMENT
    consensus = cc.PoaConsensus.FindConsensus(parts, poa_config).Sequence()

    id_ = 'poa_consensus'

    # refine the ultimate consensus using Quiver
    if quiver:
        qv_config = cc.QuiverConfig(
            cc.QvModelParams(*NoQVsModelParams.values()),
            cc.ALL_MOVES,
            cc.BandingOptions(4, 5),
            -12.5
            )

        mms = cc.SparseSseQvMultiReadMutationScorer(qv_config, consensus)

        for read in reads:
            mms.AddRead(extractFeatures(read), cc.FORWARD_STRAND)

        consensus, converge = refineConsensus(mms, QV_NITER)
        id_ = 'qv_consensus'

    output_handle.write(
        SeqRecord(
            Seq(consensus, single_letter_alphabet),
            id=id_,
            name=id_,
            description=id_
            ).format('fasta')
        )

    return 0


if __name__ == '__main__':
    from argparse import ArgumentParser, ArgumentTypeError, FileType

    parser = ArgumentParser(description=(
        "Use PacBio's ConsensusCore PoaConsensus algorithm to generate a consensus"
        ))

    def posint(string):
        try:
            v = int(string)
            assert v > 0
            return v
        except (AssertionError, ValueError):
            raise ArgumentTypeError(
                'must be a positive integer greater than 0'
                )

    parser.add_argument(
        'bam',
        metavar='BAM',
        type=FileType('rb'),
        help='the input sequences, in BAM format'
        )
    parser.add_argument(
        '-c', '--coverage',
        metavar='NUM',
        type=posint,
        default=200,
        help='number of reads to use in intermediate POA consensus estimation'
        )
    parser.add_argument(
        '-n', '--nestimates',
        metavar='NUM',
        type=posint,
        default=40,
        help='number of intermediate POA consensus estimates'
        )
    parser.add_argument(
        '-o', '--output',
        metavar='FASTA',
        type=FileType('w'),
        default=sys.stdout,
        help='output FASTA file'
        )
    parser.add_argument(
        '-q', '--quiver',
        action='store_true',
        help='use Quiver algorithm to refine consensus'
        )
    parser.add_argument(
        '-w', '--window-size',
        metavar='NUM',
        type=posint,
        default=25,
        help='default sliding window size'
        )

    args = None
    retcode = -1
    try:
        args = parser.parse_args()
        bam_file = args.bam.name
        args.bam.close()
        retcode = main(
            bam_file,
            args.output,
            args.coverage,
            args.nestimates,
            args.quiver,
            args.window_size
            )
    finally:
        if args:
            if args.output != sys.stdout:
                args.output.close()

    sys.exit(retcode)
